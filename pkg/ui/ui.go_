package ui

import (
	"image/color"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/canvas"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/layout"
	"fyne.io/fyne/v2/theme"
	"fyne.io/fyne/v2/widget"
)

// application UI
type UI struct {
	app   fyne.App
	wMain fyne.Window

	// Tabs
	appTabs *container.AppTabs

	// Choice
	choiceTab     *container.TabItem
	choiceToolBar *widget.Toolbar

	// Frame with photos
	frame *Frame
	// Frame scroll buttons
	prevPhotoBtn  *widget.Button
	prevFrameBtn  *widget.Button
	firstPhotoBtn *widget.Button
	nextPhotoBtn  *widget.Button
	nextFrameBtn  *widget.Button
	lastPhotoBtn  *widget.Button

	// List
	listTab     *container.TabItem
	listToolBar *widget.Toolbar

	// List table column headers
	headerFileName    *ActiveHeader
	headerEXIF        *ActiveHeader
	headerFileDate    *ActiveHeader
	headerEnteredDate *ActiveHeader
	headerDropped     *ActiveHeader

	// List table
	listTable *widget.Table
}

// make main window layout
func (i *UI) layout() {
	i.frame.reorder(i.frame.Order)
	i.frame.init()
	contentTabs := container.NewAppTabs(l.newChoiceTab(), l.newListTab())
	contentTabs.SetTabLocation(container.TabLocationBottom)
	wMain.SetContent(contentTabs)
}

// Choice tab frame - row with photos
type Frame struct {
	*fyne.Container
	*PhotoList
	pos  int
	size int
}

// scroll frame at position pos
func (f *Frame) scroll(pos int) {

	switch {
	case pos < 0:
		pos = 0
	case pos > len(f.List)-f.size:
		pos = len(f.List) - f.size
	}

	switch {
	case pos-f.pos >= f.size || f.pos-pos >= f.size:
		for i := f.pos; i < f.pos+f.size; i++ {
			f.List[i].Img = nil
		}
		for i := pos; i < pos+f.size; i++ {
			f.List[i].Img = f.List[i].img(f.size)
			if f.List[i].Droped {
				f.List[i].Img.Translucency = 0.5
			}
		}
	case pos > f.pos:
		for i := f.pos; i < pos; i++ {
			f.List[i].Img = nil
			f.List[i+f.size].Img = f.List[i+f.size].img(f.size)
			if f.List[i+f.size].Droped {
				f.List[i+f.size].Img.Translucency = 0.5
			}
		}
	case f.pos > pos:
		for i := pos; i < f.pos; i++ {
			f.List[i+f.size].Img = nil
			f.List[i].Img = f.List[i].img(f.size)
			if f.List[i].Droped {
				f.List[i].Img.Translucency = 0.5
			}
		}
	}

	// TODO: may be optimized when for scroll les than frame size by not all objects deletion/addition? Somwthing like this:
	// https://stackoverflow.com/questions/63995289/how-to-remove-objects-from-golang-fyne-container
	f.RemoveAll()
	for i := 0; i < f.size; i++ {
		f.Add(f.List[pos+i].FrameColumn())
	}
	f.Refresh()

	f.pos = pos
}

// resize frame
func (f *Frame) resize(zoom int) {

	switch zoom {
	case RemoveColumn:
		if f.size-1 < MinFrameSize {
			return
		}
		f.List[f.pos+f.size-1].Img = nil
		f.size--
	case AddColumn:
		if f.size+1 > MaxFrameSize || f.size+1 > len(f.List) {
			return
		}
		i := f.pos + f.size
		if i == len(f.List) {
			f.pos--
			i = f.pos
		}
		f.List[i].Img = f.List[i].img(f.size)
		if f.List[i].Droped {
			f.List[i].Img.Translucency = 0.5
		}
		f.size++
	}
	//      0-1-2-3-4-5-6-7-8
	//          2-3-4			p=2, s=3
	// 		0-1-2				p=0, s=3
	// 					6-7-8	p=6, s=3

	// TODO: may be optimized when for scroll les than frame size by not all objects deletion/addition? Somwthing like this:
	// https://stackoverflow.com/questions/63995289/how-to-remove-objects-from-golang-fyne-container
	f.RemoveAll()
	for i := 0; i < f.size; i++ {
		f.Add(f.List[f.pos+i].FrameColumn())
	}
	f.Layout = layout.NewGridLayoutWithColumns(len(f.Objects))
	f.Refresh()
}

// fill frame with photo images starting from pos = 0.
func (f *Frame) init() {
	if f.size > len(f.List) {
		f.size = len(f.List)
	}
	if f.size == 0 { // Workaround for fyne v.2.3.1 NewGridWithColumns(0) main window shrink on Windows OS  !!! Remove this when issue #3669 will be closed
		f.Container = container.NewGridWithColumns(1, canvas.NewText("", color.Black))
		return
	}
	for i := f.pos; i < f.pos+f.size && i < len(f.List); i++ {
		f.List[i].Img = f.List[i].img(f.size)
	}
	f.Container = container.NewGridWithColumns(f.size)
	for i := 0; i < f.size && i < len(f.List); i++ {
		f.Add(f.List[f.pos+i].FrameColumn())
	}
}

// Application custom theme and interface inplementation
type Theme struct{}

func (t *Theme) Color(name fyne.ThemeColorName, variant fyne.ThemeVariant) color.Color {
	switch name {
	case theme.ColorNameButton:
		return color.Transparent
	}
	return theme.DefaultTheme().Color(name, variant)
}

func (t *Theme) Font(style fyne.TextStyle) fyne.Resource {
	if style.Monospace {
		return regular
	}
	if style.Bold {
		if style.Italic {
			return bolditalic
		}
		return bold
	}
	if style.Italic {
		return italic
	}
	if style.Symbol {
		return regular
	}
	return regular
}

func (t *Theme) Icon(name fyne.ThemeIconName) fyne.Resource {
	return theme.DefaultTheme().Icon(name)
}

func (t *Theme) Size(name fyne.ThemeSizeName) float32 {
	return theme.DefaultTheme().Size(name)
}
